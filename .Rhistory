<<<<<<< HEAD
temp[[1]]
temp = lapply(out,function(x) x[which.max(x[,3]),-c(1,2)])
temp[[1]]
temp = lapply(out,function(x) x[3,-c(1,2)])
fun = function(x){
tp = sum(which(x!=0) %in% c(2:(n0+1)))
fp = sum(x!=0) -tp -1
tpr = tp/n0
fpr = fp/(M-n0)
return(c(tpr,fpr))
}
tt = lapply(temp,fun)
xx = do.call(rbind,tt)
xx
temp = lapply(out,function(x) x[3,-c(1,2)])
fun = function(x){
tp = sum(which(x!=0) %in% c(2:(n0+1)))
fp = sum(x!=0) -tp -1
tpr = tp/n0
fpr = fp/(n-n0)
return(c(tpr,fpr))
=======
t2 = rowSums(log(1-A)[,setdiff(1:n,pid)])
#t1 = t(t(log(A)*G[t,])); t1[is.nan(t1)] = 0 # log(0^0)=0
#t2 = t(t(log(1-A)*(1-G[t,]))); t2[is.nan(t2)] = 0
btm[t,] = t1+t2 + log(rho)
}
pid
T
t
dim(t1)
dim(t2)
t1
t2
rho
log(rho)
btm[1,]
btm[2,]
ct = apply(btm,1,max)
dim(btm)
dim(ct)
ct
rowSums(temp)
range(rowSums(temp))
log(11)
log(rowSums(temp))
sum(ct+log(rowSums(temp)))
T = dim(G)[1]; q = dim(A)[1]
Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
## posterior probability H and loglikelihood
Pr_G = t(t(Pr_cond)*rho)
id = which(rowSums(Pr_G)==0)
print(id)
H = matrix(0,T,q)
H = Pr_G/rowSums(Pr_G)
loglike = sum(log(rowSums(Pr_G)))
Pr_G
dim(Pr_G)
G[1,]
Pr_G[1,]
log(Pr_G[1,])
btm[1,]
exp(-200)
log(expm1(-200)+1)
log(exp(-200)+exp(-300)+exp(-100))
exp(-500)
exp(-700)
exp(-80000)
A = matrix(rep(0.001,1000*200),1000,200)
A
log(sum(apply(A,1,prod)))
A = matrix(rep(0.01,1000*200),1000,200)
log(sum(apply(A,1,prod)))
A = matrix(rep(0.1,1000*200),1000,200)
log(sum(apply(A,1,prod)))
exp(-200)
log(1.383897e-87)
log(1.383896e-87)
c=sum(log(A[1,]))
c
c = log(0.1)
source('~/Documents/R/Phub/R/Main.R')
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.008,pen.type="plog")
posterior = function(G,A,rho){
T = dim(G)[1]; q = dim(A)[1]
H = Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
## posterior probability H and loglikelihood
Pr_G = t(t(Pr_cond)*rho)
# the condtional probability is extremely small for some t
# devide the sample into 2 parts
id = which(rowSums(Pr_G)==0)   # unnormal sample index
Pr_G1 = Pr_G[setdiff(1:T,id),] # normal group
H[setdiff(1:T,id),] = Pr_G1/rowSums(Pr_G1)
l1 = sum(log(rowSums(Pr_G))); l2 = 0
btm = matrix(NA,length(id),q)
if(length(id)!=0){
for(ii in 1:length(id)){
pid = which(G[ii,]==1)
if(length(pid)!=0) t1 = apply(A,1,function(x)sum(x[pid]))
else t1 = rep(0,q)
t2 = rowSums(log(1-A)[,setdiff(1:n,pid)])
btm[ii,] = t1+t2+log(rho)
}
ct = apply(btm,1,max)
l2 = sum(ct+log(rowSums(exp(btm-ct))))
H[id,] = t(apply(exp(btm-ct),1,function(x) x/sum(x)))
}
return(list(H=H,l=l1+l2))
}
hatrho = function(rho,H){
T = dim(G)[1]
Hx = colSums(H)
ind = which(rho!=0); len = length(ind)
eqft = function(t) sum(t)
if(pen.type=="plasso"){
# convex function
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-t[1])
pars = Rsolnp::solnp(pars=rho[ind],fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),
UB=rep(1,len),control=list(trace=0))$pars
}
else{
epsi = 1e-8
ans = list()
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*sum(log(epsi+t[-1]))
fun = function(i){
if(i==1) par = rho[ind]
else {par = runif(len); par = par/sum(par)} # normalized
sol = Rsolnp::solnp(pars=par,fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),
UB=rep(1,len),control=list(trace=0))
ans$pars = sol$pars
ans$values = tail(sol$values,1)
return(ans)
}
# adding one initial values rho from the last step.
fval = lapply(as.list(1:3),fun) # repeatation
best = sapply(fval,function(x) x$values)
pars = fval[[which.min(best)]]$pars
}
pars[pars<tol] = 0
pars[1] = 1 - sum(pars[-1]) # sum is 1
rho[ind] = pars
return(rho)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # Amm must be 1
return(HatA)
}
count = 0;diff = 1
L = vector();L[1] = 1
G0=G
lam
n0
M
T
pr
rho
lam=0.010
count = 0;diff = 1
L = vector();L[1] = 1
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
pen.type="plog"
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
iter.max=1000
tol=1e-4
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
t1$rho
t1$l
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
x=phub.base(G,A,rho)
x=phub.base(G,A,rho,0.10)
x$rho
x$l
source('~/.active-rstudio-document')
x=phub.base(G,A,rho,0.13)
x$rho
x$l
x=phub.base(G,A,rho,0.14)
rm(list=ls())
load("sln1.RData")
out[1]
out[2]
rm(list=ls())
load("sl1.RData")
out[1]
count = 0;diff = 1
L = vector();L[1] = 1
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
G = post$G # some rows may be deleted
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
rm(list=ls())
n0 = 10; n=100
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
pen.type="plog"
lam=0.10
G=G0
posterior = function(G,A,rho){
T = dim(G)[1]; q = dim(A)[1]
H = Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
## posterior probability H and loglikelihood
Pr_G = t(t(Pr_cond)*rho)
# the condtional probability is extremely small for some t
# devide the sample into 2 parts
id = which(rowSums(Pr_G)==0)   # unnormal sample index
Pr_G1 = Pr_G[setdiff(1:T,id),] # normal group
H[setdiff(1:T,id),] = Pr_G1/rowSums(Pr_G1)
l1 = sum(log(rowSums(Pr_G))); l2 = 0
btm = matrix(NA,length(id),q)
if(length(id)!=0){
for(ii in 1:length(id)){
pid = which(G[ii,]==1)
if(length(pid)!=0) t1 = apply(A,1,function(x)sum(x[pid]))
else t1 = rep(0,q)
t2 = rowSums(log(1-A)[,setdiff(1:n,pid)])
btm[ii,] = t1+t2+log(rho)
}
ct = apply(btm,1,max)
l2 = sum(ct+log(rowSums(exp(btm-ct))))
H[id,] = t(apply(exp(btm-ct),1,function(x) x/sum(x)))
}
return(list(H=H,l=l1+l2))
}
hatrho = function(rho,H){
T = dim(G)[1]
Hx = colSums(H)
ind = which(rho!=0); len = length(ind)
eqft = function(t) sum(t)
if(pen.type=="plasso"){
# convex function
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-t[1])
pars = Rsolnp::solnp(pars=rho[ind],fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),
UB=rep(1,len),control=list(trace=0))$pars
>>>>>>> edaae5432191405fcff61ac5228cfd7d7fefe3d5
}
else{
epsi = 1e-8
ans = list()
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*sum(log(epsi+t[-1]))
fun = function(i){
if(i==1) par = rho[ind]
else {par = runif(len); par = par/sum(par)} # normalized
sol = Rsolnp::solnp(pars=par,fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),
UB=rep(1,len),control=list(trace=0))
ans$pars = sol$pars
ans$values = tail(sol$values,1)
return(ans)
}
# adding one initial values rho from the last step.
fval = lapply(as.list(1:3),fun) # repeatation
best = sapply(fval,function(x) x$values)
pars = fval[[which.min(best)]]$pars
}
pars[pars<tol] = 0
pars[1] = 1 - sum(pars[-1]) # sum is 1
rho[ind] = pars
return(rho)
}
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # Amm must be 1
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
iter.max=1000
tol=1e-4
rho = hatrho(rho,H)
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count+1])
count = count + 1
# E Step
post = posterior(G,A,rho)
H = post$H
L[count+1] = post$l
cat("count and likelihood:",c(count,tail(L,1)),sep="\n")
if(is.infinite(L[count+1])) break
if(is.na(tail(L,1))) break
# M Step
rho = hatrho(rho,H)
A = hatA(G,H)
L
T = dim(G)[1]; q = dim(A)[1]
H = Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
## posterior probability H and loglikelihood
Pr_G = t(t(Pr_cond)*rho)
dim(Pr_G)
rowSums(Pr_G)
# the condtional probability is extremely small for some t
# devide the sample into 2 parts
id = which(rowSums(Pr_G)==0)   # unnormal sample index
id
Pr_G1 = Pr_G[setdiff(1:T,id),] # normal group
H[setdiff(1:T,id),] = Pr_G1/rowSums(Pr_G1)
l1 = sum(log(rowSums(Pr_G))); l2 = 0
btm = matrix(NA,length(id),q)
l1
source('~/Documents/R/Phub/R/Main.R')
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.008,pen.type="plog")
t1$rho
t1$l
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.008,pen.type="plog")
t1$l
t1$rho
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.009,pen.type="plog")
t1$rho
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.010,pen.type="plog")
t1$rho
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.013,pen.type="plog")
t1$rho
n0 = 20; n=100
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.008,pen.type="plog")
t1$rho
fun = function(x){
tp = sum(which(x!=0) %in% c(2:(n0+1)))
fp = sum(x!=0) - tp -1
tpr = tp/n0
fpr = fp/(M*5)
return(c(tpr,fpr))
}
fun(t1$rho)
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.009,pen.type="plog")
t1$rho
fun(t1$rho)
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.010,pen.type="plog")
fun(t1$rho)
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.011,pen.type="plog")
fun(t1$rho)
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.007,pen.type="plog")
fun(t1$rho)
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.006,pen.type="plog")
fun(t1$rho)
n0 = 20; n=500
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.008,pen.type="plog")
n0 = 20; n=500
A0 = GenA(n,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.008,pen.type="plog")
fun(t1$rho)
fun
}
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.006,pen.type="plog")
fun
}
fun = function(x){
tp = sum(which(x!=0) %in% c(2:(n0+1)))
fp = sum(x!=0) - tp -1
tpr = tp/n0
fpr = fp/(M)
return(c(tpr,fpr))
}
fun(t1$rho)
t1$rho
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.012,pen.type="plog")
fun(t1$rho)
t1$rho
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.015,pen.type="plog")
fun(t1$rho)
t1$rho
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.018,pen.type="plog")
t1$rho
fun(t1$rho)
# t2 = phub(G0,A,rho,0.0,pen.type="log")$rho
t1 = phub(G0,A,rho,0.020,pen.type="plog")
t1$rho
fun(t1$rho)
source('~/Documents/R/Phub/R/Main.R')
devtools::document()
rm(list=ls())
getwd()
setwd("/Users/hzb/Documents/R/Phub")
devtools::document()
library(Phub)
phub
devtools::document()
library(Phub)
rm(list=ls())
delta<-0.2 # effect size
sigmasq<-1 # total variance
pisq<-0.8 # within-cluster variance
tausq = 0.1
n<-10 # number of individuals per level-two unit
j<-5 # number of level-two units per level-three unit
k<-30 # number of level-three units
# step 2: X,Z,W
A<-diag(j*k) # identity matrix
B<-array(c(1,1,1,1,1,1,1,1,1,1),dim = c(10,1)) #ones and time
X<-kronecker(A,B) #block diagonal matrix
dim(X)
colSums(X)
A1 <- diag(k)
B1 <- array(c(1,1,1,1,1,1,1,1,1,1),dim = c(5,1))
Z <- kronecker(A1,B1)
dim(Z)
colSums(Z)
# X2
x2 <- matrix(c(array(c(1,1,1,1,1,1,1,1,1,1),dim = c(k,1)), rnorm(k, mean = 0, sd=0.1)), nrow = k,ncol = 2)
dim(x2)
x2
install.packages("Matrix")
library(Matrix)
?kronecker
M <- matrix(1:6, ncol = 2)
M
diag(1, 3)
kronecker(diag(1, 3), M)
B <- array(c(1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10), dim=c(10,2))
B
n=10
j=50
A <- diag(j)
B <- array(c(1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10), dim=c(10,2))
X <- kronecker(A,B)
dim(X)
head(X)
colSums(X)
A <- diag(j)
B <- array(c(1,1,1,1,1,1,1,1,1,1,rep(0.10)), dim=c(10,2))
X <- kronecker(A,B)
colSums(X)
j
n
View(X)
A <- diag(j)
B <- array(c(1,1,1,1,1,1,1,1,1,1,rep(0,10)), dim=c(10,2))
X <- kronecker(A,B)
colSums(X)
Zmean1 <- 1
Zmean2 <- 2
Zmean3 <- 3
Zmean4 <- 4
Zmean5 <- 5
B1 <- matrix(data=c(1,0,Zmean1,0,0,1,0,Zmean1), nrow=2, ncol=4)
A1 <- array(1, dim=c(j/5,1))
B1
A1 <- array(1, dim=c(j/5,1))
Z1 <- kronecker(A1,B1)
Z1
Zmean1 <- 1
Zmean2 <- 2
Zmean3 <- 3
Zmean4 <- 4
Zmean5 <- 5
B1 <- matrix(data=c(1,0,Zmean1,0,0,1,0,Zmean1), nrow=2, ncol=4)
A1 <- array(1, dim=c(j/5,1))
Z1 <- kronecker(A1,B1)
B2 <- matrix(data=c(1,0,Zmean2,0,0,1,0,Zmean2), nrow=2, ncol=4)
A2 <- array(1, dim=c(j/5,1))
Z2 <- kronecker(A2,B2)
B3 <- matrix(data=c(1,0,Zmean3,0,0,1,0,Zmean3), nrow=2, ncol=4)
A3 <- array(1, dim=c(j/5,1))
Z3 <- kronecker(A3,B3)
B4 <- matrix(data=c(1,0,Zmean4,0,0,1,0,Zmean4), nrow=2, ncol=4)
A4 <- array(1, dim=c(j/5,1))
Z4 <- kronecker(A4,B4)
B5 <- matrix(data=c(1,0,Zmean5,0,0,1,0,Zmean5), nrow=2, ncol=4)
A5 <- array(1, dim=c(j/5,1))
Z5 <- kronecker(A5,B5)
Z <- rbind(Z1,Z2,Z3,Z4,Z5)
Z
Zmean1 <- 1
Zmean2 <- 2
Zmean3 <- 3
Zmean4 <- 4
Zmean5 <- 5
B1 <- matrix(data=c(1,0,Zmean1,0,0,1,0,Zmean1), nrow=2, ncol=4)
A1 <- array(1, dim=c(j/5,1))
Z1 <- kronecker(A1,B1)
B2 <- matrix(data=c(1,0,Zmean2,0,0,1,0,Zmean2), nrow=2, ncol=4)
A2 <- array(1, dim=c(j/5,1))
Z2 <- kronecker(A2,B2)
B3 <- matrix(data=c(1,0,Zmean3,0,0,1,0,Zmean3), nrow=2, ncol=4)
A3 <- array(1, dim=c(j/5,1))
Z3 <- kronecker(A3,B3)
B4 <- matrix(data=c(1,0,Zmean4,0,0,1,0,Zmean4), nrow=2, ncol=4)
A4 <- array(1, dim=c(j/5,1))
Z4 <- kronecker(A4,B4)
B5 <- matrix(data=c(1,0,Zmean5,0,0,1,0,Zmean5), nrow=2, ncol=4)
A5 <- array(1, dim=c(j/5,1))
Z5 <- kronecker(A5,B5)
Z <- rbind(Z1,Z2,Z3,Z4,Z5)
Z
j = 50
n=10
D <- list()
set.seed(4321)
for (i in 1:j) {
zj <- rnorm(1, mean=meanz, sd=sdz)
Dz1 <- c(1, zj, 0, 0)
Dz2 <- c(0, 0, 1, zj)
D[[i]] <- rbind(Dz1, Dz2)
}
E <- list()
for (i in 1:j) {
if (i == 1) {E[[i]] <- D[[1]]}
else {E[[i]] <- rbind(E[[i-1]], D[[i]])}
}
Z <- E[[j]]
meanx <- 0
sdx <- 1
meanz <- 0
sdz <- 1
D <- list()
set.seed(4321)
for (i in 1:j) {
zj <- rnorm(1, mean=meanz, sd=sdz)
Dz1 <- c(1, zj, 0, 0)
Dz2 <- c(0, 0, 1, zj)
D[[i]] <- rbind(Dz1, Dz2)
}
E <- list()
for (i in 1:j) {
if (i == 1) {E[[i]] <- D[[1]]}
else {E[[i]] <- rbind(E[[i-1]], D[[i]])}
}
Z <- E[[j]]
Z
dim(Z)
k = 30
meanz <- 0
sdz <- 1
D <- list()
set.seed(4321)
for (i in 1:k) {
zj <- rnorm(1, mean=meanz, sd=sdz)
Dz1 <- c(1, zj)
Dz2 <- c(1, zj)
D[[i]] <- rbind(Dz1, Dz2)
}
E <- list()
for (i in 1:j) {
if (i == 1) {E[[i]] <- D[[1]]}
else {E[[i]] <- rbind(E[[i-1]], D[[i]])}
}
Z <- E[[j]]
k = 30
meanz <- 0
sdz <- 1
D <- list()
set.seed(4321)
for (i in 1:k) {
zj <- rnorm(1, mean=meanz, sd=sdz)
Dz1 <- c(1, zj)
Dz2 <- c(1, zj)
D[[i]] <- rbind(Dz1, Dz2)
}
E <- list()
for (i in 1:k) {
if (i == 1) {E[[i]] <- D[[1]]}
else {E[[i]] <- rbind(E[[i-1]], D[[i]])}
}
Z <- E[[k]]
dim(Z)
k = 30
meanz <- 0
sdz <- 1
D <- list()
set.seed(4321)
for (i in 1:k) {
zj <- rnorm(1, mean=meanz, sd=sdz)
Dz1 <- c(1, zj)
D[[i]] <- Dz1
}
E <- list()
for (i in 1:k) {
if (i == 1) {E[[i]] <- D[[1]]}
else {E[[i]] <- rbind(E[[i-1]], D[[i]])}
}
Z <- E[[k]]
dim(Z)
Z
barplot(Z[,2])
hist(Z[,2])
t=-100:0
plot(x=t,y=exp(-2*t),col="red",lwd=2)
lines(x=t,y=exp(-3*t),col="blue",lwd=2)
t=0:10
plot(x=t,y=exp(-2*t),col="red",lwd=2)
lines(x=t,y=exp(-3*t),col="blue",lwd=2)
t=0:100
plot(x=t,y=exp(-2*t),col="red",lwd=2)
lines(x=t,y=exp(-3*t),col="blue",lwd=2)
t=0:100
plot(x=t,y=exp(-2*t),col="red",lwd=2)
lines(x=t,y=exp(-10*t),col="blue",lwd=2)
t=0:20
plot(x=t,y=exp(-3*t),col="red",lwd=2)
lines(x=t,y=exp(-10*t),col="blue",lwd=2)
cbind(exp(-3*t),exp(-10*t))
rm(list=ls())
set.seed(1990)
n0 = 10; n=500
A0 = GenA(100,n0,0.4,0.02,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
#t1 = phub(G0,A,rho,0.010,pen.type="log")
tt = phub(G0,A,rho,0.015,pen.type="plog")
rm(list=ls())
library(forach)
library(Phub)
## new GenA
library(foreach)
set.seed(1990)
n0 = 10; n=500
A0 = GenA(100,n0,0.4,0.02,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
#t1 = phub(G0,A,rho,0.010,pen.type="log")
tt = phub(G0,A,rho,0.015,pen.type="plog")
set.seed(1990)
n0 = 10; n=500
A0 = GenA(n,n0,0.4,0.02,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 80
# initial A
A = matrix(NA,M,n)
for(i in 1:M)A[i,] = colSums(G0[,i]*G0)/sum(G0[,i])
diag(A) = 1; A = rbind(runif(n),A)
# initial rho
rho = c(0.2,rep(0.8/M,M))
#t1 = phub(G0,A,rho,0.010,pen.type="log")
tt = phub(G0,A,rho,0.015,pen.type="plog")
fun = function(x){
tp = sum(which(x!=0) %in% c(2:(n0+1)))
fp = sum(x!=0) - tp -1
tpr = tp/n0
fpr = fp/M
return(c(tpr,fpr))
}
fun(tt$rho)
#t1 = phub(G0,A,rho,0.010,pen.type="log")
tt = phub(G0,A,rho,0.012,pen.type="plog")
tt$rho
fun(tt$rho)
load("sl2.RData")
getwd()
dir()
setwd("/home/zhibing/R")
dir()
load("sl2.RData")
out[[1]]

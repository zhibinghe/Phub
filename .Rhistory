EMM.hub(G0,M,0.02)
EMM.hub(G0,M,0.01)
EMM.hub(G0,M,0.03)
EMM.hub(G0,M,0.035)
sqrt(1000)
1/1000
1/31.62278
countdecimals(1.1)
x=1/sqrt(1000)
x
floor(x)
format(x,scientific = T)
xx=format(x,scientific = T)
split(xx)
split(xx,"")
class(xx)
strip(xx)
M = 50; EMM.hub(G0,M,0.03)
M = 50; EMM.hub(G0,M,0.021)
M = 50; EMM.hub(G0,M,0.035)
M = 50; EMM.hub(G0,M,0.015)
M = 50; EMM.hub(G0,M,0.01)
M = 50; EMM.hub(G0,M,0.06)
M = 50; EMM.hub(G0,M,0.08)
M = 50; EMM.hub(G0,M,0.012)
M = 50; EMM.hub(G0,M,0.018)
EM.hub = function(G,A,rho,lam,iter=1000){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; M = dim(A)[1]
Pr_cond = matrix(NA,T,M)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1];M = dim(Pr_cond)[2]
H = matrix(NA,T,M)
Htm = t(t(Pr_cond)*rho)
# if Gm(t)=0 then m cannot be leader in t(th) group
ind = which(rowSums(Htm)==0)
if(length(ind)==0) H[,] = Htm/rowSums(Htm)
else
H[ind,] = 0
H[-ind,] = Htm[-ind,]/rowSums(Htm[-ind,])
loglik = sum(log(rowSums(Htm)))
loglik[loglik==-Inf] = -9*10^5 # avoid likelihood being -inf
return(list(H=H,l=loglik))
}
## update rho: some rho will shrink to 0
hatrho = function(H,Mi,lam) sapply((colMeans(H) - lam)/(1-Mi*lam),function(x) max(0,x))
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
M = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,M,n)
for(m in 1:M){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while((count < iter & diff > 10^(-6))){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
# M Step
Mi = sum(rho!=0)
if(Mi*lam==1) stop("Please input a new lam avoiding 1-M*lam is 0")
rho = hatrho(H,Mi,lam)
if(all(rho==0)) break
A = hatA(G,H)
diff = abs((L[count+1]-L[count])/L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
EMM.hub = function(G,M,lam,iter=1000){
T = dim(G)[1]; n = dim(G)[2]
A = matrix(NA,M,n)
A[1,] = colMeans(G) # nonleader group
for(m in 2:M){
if(sum(G[,(m-1)])==0) A[m,] = 0
else A[m,] = colSums(G[,(m-1)]*G)/sum(G[,(m-1)])
}
diag(A[-1,]) = 1
## repeatation
outp = list(10); cur = rep(NA,10)
for(r in 1:10){
rho = runif(M); rho = rho/sum(rho)
outp[[r]] = EM.hub(G,A,rho,lam)
cur[r] = outp[[r]]$l
}
maxid = which.max(cur)
return(outp[[maxid]])
}
M = 50; EMM.hub(G0,M,0.018)
M = 10; EMM.hub(G0,M,0.04)
EMM.hub = function(G,M,lam,iter=1000){
T = dim(G)[1]; n = dim(G)[2]
A = matrix(NA,M,n)
A[1,] = colMeans(G) # nonleader group
for(m in 2:M){
if(sum(G[,(m-1)])==0) A[m,] = 0
else A[m,] = colSums(G[,(m-1)]*G)/sum(G[,(m-1)])
}
diag(A[-1,]) = 1
## repeatation
outp = list(10); cur = rep(NA,10)
for(r in 1:10){
rho = runif(M); rho = rho/sum(rho)
outp[[r]] = EM.hub(G,A,rho,lam)
cur[r] = outp[[r]]$l
}
maxid = which.max(cur)
return(outp[[maxid]])
}
EMM.hub = function(G,M,lam,iter=1000,tol=0.01){
T = dim(G)[1]; n = dim(G)[2]
A = matrix(NA,M,n)
A[1,] = colMeans(G) # nonleader group
for(m in 2:M){
if(sum(G[,(m-1)])==0) A[m,] = 0
else A[m,] = colSums(G[,(m-1)]*G)/sum(G[,(m-1)])
}
diag(A[-1,]) = 1
## repeatation
outp = list(10); cur = rep(NA,10)
for(r in 1:10){
rho = runif(M); rho = rho/sum(rho)
outp[[r]] = EM.hub(G,A,rho,lam)
cur[r] = outp[[r]]$l
}
maxid = which.max(cur)
return(outp[[maxid]])
}
M = 50; EMM.hub(G0,M,0.018)
x=c(1,2,3)
x[x>=1.5]
x = matrix(1:9,3,3)
x
x[c(2,3),]=0
x
source('~/Documents/R/Phub/R/Main.R')
EMM.hub = function(G,M,lam,iter=1000,tol=0.01){
T = dim(G)[1]; n = dim(G)[2]
A = matrix(NA,M,n)
A[1,] = colMeans(G) # nonleader group
for(m in 2:M){
if(sum(G[,(m-1)])==0) A[m,] = 0
else A[m,] = colSums(G[,(m-1)]*G)/sum(G[,(m-1)])
}
diag(A[-1,]) = 1
## repeatation
outp = list(5); cur = rep(NA,5)
for(r in 1:5){
rho = runif(M); rho = rho/sum(rho)
outp[[r]] = EM.hub(G,A,rho,lam)
cur[r] = outp[[r]]$l
}
maxid = which.max(cur)
return(outp[[maxid]])
}
M = 50; EMM.hub(G0,M,0.018)
#' Modified EM algorithm for hub model component selection
#'
#' @param G  observed group data, a T*n matrix
#' @param A  a matrix containg correlation among nodes; first row is the nonleader case
#' @param rho a vector composed of component weight; prior probability of components.
#' @param lam tuning parameter for component selection, lambda*Df; if lam=0, becomes a normal EM without penalty
#' @param iter maximum iteration steps
#' @param tol tolerated chnage for log-likelihood
#' @return a list of components
#' \item{A}{a matrix containg estimated correlation among nodes}
#' \item{rho}{a vector containing estimated component weight}
#' \item{l}{log-likelihood}
#' \item{iteration}{number of iterations used to converge}
#' @export
#'
#' @examples
#' n0 = 5; n=100
#' A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
#' G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
#' M = 11
#' A = matrix(runif(M*n),nrow=M); diag(A[-1,])=1
#' rho = runif(M); rho = rho/sum(rho)
#' EM.hub(G0,A,rho,1)
#'
EM.hub = function(G,A,rho,lam,iter=1000,tol=0.01){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; M = dim(A)[1]
Pr_cond = matrix(NA,T,M)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1];M = dim(Pr_cond)[2]
H = matrix(NA,T,M)
Htm = t(t(Pr_cond)*rho)
# if Gm(t)=0 then m cannot be leader in t(th) group
ind = which(rowSums(Htm)==0)
if(length(ind)==0) H[,] = Htm/rowSums(Htm)
else
H[ind,] = 0
H[-ind,] = Htm[-ind,]/rowSums(Htm[-ind,])
loglik = sum(log(rowSums(Htm)))
loglik[loglik==-Inf] = -9*10^5 # avoid likelihood being -inf
return(list(H=H,l=loglik))
}
## update rho: some rho will shrink to 0
hatrho = function(H,Mi,lam) sapply((colMeans(H) - lam)/(1-Mi*lam),function(x) max(0,x))
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
M = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,M,n)
for(m in 1:M){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while((count < iter & diff > tol)){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
# M Step
Mi = sum(rho!=0)
if(Mi*lam==1) stop("Please input a new lam avoiding 1-M*lam is 0")
rho = hatrho(H,Mi,lam)
if(all(rho==0)) break
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
## delete too small rho
thres = 0.05
A[(rho<thres),] = 0
rho[rho<thres] = 0
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
M = 50; EMM.hub(G0,M,0.02)
M = 50; EMM.hub(G0,M,0.022)
M = 50; EMM.hub(G0,M,0.017)
M = 50; EMM.hub(G0,M,0.019)
M = 10; EMM.hub(G0,M,0.04)
M = 20; EMM.hub(G0,M,0.035)
EMM.hub = function(G,M,lam,iter=1000,tol=0.01){
T = dim(G)[1]; n = dim(G)[2]
A = matrix(NA,M,n)
A[1,] = colMeans(G) # nonleader group
for(m in 2:M){
if(sum(G[,(m-1)])==0) A[m,] = 0
else A[m,] = colSums(G[,(m-1)]*G)/sum(G[,(m-1)])
}
diag(A[-1,]) = 1
## repeatation
outp = list(10); cur = rep(NA,10)
for(r in 1:10){
rho = runif(M); rho = rho/sum(rho)
outp[[r]] = EM.hub(G,A,rho,lam)
cur[r] = outp[[r]]$l
}
maxid = which.max(cur)
return(outp[[maxid]])
}
M = 20; EMM.hub(G0,M,0.035)
M = 10; EMM.hub(G0,M,0.04)
M = 10;
res=EMM.hub(G0,M,0.04)
out=res
sum(out$rho!=0)
out[[1]]=res
out
length(out)
rm(out)
out=list()
out[[1]]=res
length(out)
i=1
out[[i]]$l - 0.5*sum(out[[i]]$rho!=0)*log(T)
out[[i]]$l
0.5*sum(out[[i]]$rho!=0)*log(T)
sum(out[[i]]$rho!=0)
T
T = dim(G)[1]
T=1000
0.5*sum(out[[i]]$rho!=0)*log(T)
n=100
0.5*n*sum(out[[i]]$rho!=0)*log(T)
n0 = 5; n=100
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
##
vlam = seq(0.01,0.1,0.01)
T = dim(G0)[1]; n = dim(G0)[2]
out = vector("list",length=length(vlam))
vbic = vl = rep(NA,length(vlam))
for(i in 1:length(vlam)){
lam = vlam[i]
out[[i]] = EMM.hub(G0,20,lam)
vbic[i] = out[[i]]$l - 0.5*n*sum(out[[i]]$rho!=0)*log(T)
}
vbic
out[[1]]
devtools::document()
devtools::document()
getwd()
dir()
library(Phub)
## Generate simulation data
n0 = 5 # number of true leaders
n=100 # number of total nodes
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n)) # true adjacent matrix
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0))) # observed data
## Testing EM.hub
M = 11 # number of initial components
A = matrix(runif(M*n),nrow=M); diag(A[-1,])=1 # initial A matrix
rho = runif(M); rho = rho/sum(rho) # initial component weights
EM.hub(G0,A,rho,0.3) # EM estimation
EM.hub(G0,A,rho,0.03) # EM estimation
EM.hub(G0,A,rho,0.04) # EM estimation
EM.hub(G0,A,rho,0.05) # EM estimation
EM.hub(G0,A,rho,1) # EM estimation
EM.hub(G0,A,rho,0.2) # EM estimation
EM.hub(G0,A,rho,0.6) # EM estimation
EM.hub(G0,A,rho,0.5) # EM estimation
EM.hub(G0,A,rho,0.3) # EM estimation
## Testing EMM.hub
M = 10
EMM.hub(G0,M,0.04) # EM with multiple start points
## Testing EM.hub
M = 10 # number of initial components
A = matrix(runif(M*n),nrow=M); diag(A[-1,])=1 # initial A matrix
rho = runif(M); rho = rho/sum(rho) # initial component weights
EM.hub(G0,A,rho,0.3) # EM estimation
EM.hub(G0,A,rho,0.03) # EM estimation
M = 11 # number of initial components
A = matrix(runif(M*n),nrow=M); diag(A[-1,])=1 # initial A matrix
rho = runif(M); rho = rho/sum(rho) # initial component weights
EM.hub(G0,A,rho,0.03) # EM estimation
EM.hub(G0,A,rho,0.05) # EM estimation
M = 20
EMM.hub(G0,M,0.035)
vbic
vlam = seq(0.011,0.99,0.01)
T = dim(G0)[1] # sample size
n = dim(G0)[2]
out = vector("list",length=length(vlam))
vbic = vl = rep(NA,length(vlam))
for(i in 1:length(vlam)){
lam = vlam[i]
out[[i]] = EMM.hub(G0,M=20,lam)
# BIC
Mi = sum(out[[i]]$rho!=0)
vbic[i] = out[[i]]$l - 0.5*log(T)*(n*Mi-Mi+1)
}
vbic
which.max(vbic)
out[[which.max(vbic)]]
vlam = seq(0.011,0.99,0.01)
vlam
out1 = out[[1:85]]
length(out)
x=out[[4]]
x
which(x$rho!=0)
tnode = c(1,2,3,4,5,6)
x=c(1,2,7)
intersect(tnode,x)
tnode = c(1,2,3,4,5,6)
nc = ntc = rep(NA,length(vlam))
for(i in 1:length(vlam)){
nc[i] = sum(out[[i]]$rho!=0)
ntc = length(intersect(tnode,which(out[[i]]!=0)))
}
tnode = c(1,2,3,4,5,6)
nc = ntc = rep(NA,length(vlam))
for(i in 1:length(vlam)){
nc[i] = sum(out[[i]]$rho!=0)
ntc = length(intersect(tnode,which(out[[i]]$rho!=0)))
}
nc
ntc
tnode = c(1,2,3,4,5,6)
nc = ntc = rep(NA,length(vlam))
for(i in 1:length(vlam)){
nc[i] = sum(out[[i]]$rho!=0)
ntc[i] = length(intersect(tnode,which(out[[i]]$rho!=0)))
}
ntc
plot(nc)
plot(nc,"l")
plot(nc,type="l")
plot(ntc,type="l")
plot(nc,type="l")
cbind(nc,ntc)
cbind(nc,ntc,vlam)
save.image("testbic.RData")
devtools::document()
devtools::document()
library(Phub)
example(EM.hub)
testf = function(x){
if(x==10) stop("this number cannot be 10")
print("OK")
}
for(i in 20) testf(i)
testf = function(x){
if(x==10) stop("this number cannot be 10")
print("ok")
return(x)
}
for(i in 20) testf(i)
for(i in 1: 20) testf(i)
for(i in 1: 20) tryCatch{testf(i)}
for(i in 1: 20) tryCatch(testf(i))
for(i in 1: 20) tryCatch(testf(i))
size=20
out = rep(NA,size)
for(i in 1: size) {
out[i] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i])) next
}
length(out)
out
xx= try(testf(10))
xx
class(xx)
size=20
out = rep(NA,size)
for(i in 1: size) {
out[i] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i])) out[i]=100
}
testf = function(x){
if(x==10) stop("this number cannot be 10")
return(x)
}
size=20
out = rep(NA,size)
for(i in 1: size) {
out[i] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i])) out[i]=100
}
out
size=20
out = rep(NA,size)
for(i in 1: size) {
out[i] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i])) out[i]=100
}
out
?try
size=20
out = matrix(NA,size,3)
for(i in 1: size) {
out[i,] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i,])){
}
}
out
size=20
out = matrix(NA,size,3)
for(i in 1: size) {
out[i,] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i,])){
out[i,]= 100
}
}
out
xx=out[10,]
xx
if("try-error" %in% xx)
)
"try-error" %in% xx
class(xx)
class(xx[1])
xx[1]
class(xx[1])
out = rep(NA,size)
for(i in 1: size) {
out[i] = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out[i])){
out[i]= 100
}
}
out
out[10]
class(out[10])
xx=try(testf(10),silent=TRUE)
xx
class(xx)
size=20
res = matrix(NA,size,3)
for(i in 1: size) {
out = try(testf(i),silent=TRUE)
if ('try-error' %in% class(out)) res[i,] = NA
else res[i,] = out
}
res
sum(is.na(res[,1]))

EM.opt(G0,A,rho,0.04)$rho
EM.opt(G0,A,rho,0.1)$rho
M
A = matrix(runif((M+1)*n),nrow=(M+1)); diag(A[-1,])=1
rho = runif(M); rho = rho/sum(rho)
EM.opt(G0,A,rho,0.2)$rho
EM.opt(G0,A,rho,0.1)$rho
EM.opt(G0,A,rho,0.08)$rho
A = matrix(runif(M*n),nrow=M); diag(A[-1,])=1
rho = runif(M+1); rho = rho/sum(rho)
EM.hub(G0,A,rho,0.015)$rho
A = matrix(runif((M+1)*n),nrow=(M+1)); diag(A[-1,])=1
rho = runif(M+1); rho = rho/sum(rho)
EM.hub(G0,A,rho,0.015)$rho
EM.hub(G0,A,rho,0.035)$rho
EM.hub(G0,A,rho,0.045)$rho
EM.hub(G0,A,rho,0.030)$rho
EM.hub(G0,A,rho,0.025)$rho
EM.opt(G0,A,rho,0.08)$rho
EM.opt(G0,A,rho,0.1)$rho
EM.opt(G0,A,rho,0.06)$rho
rho
dim(A)
EM.opt(G0,A,rho,0.05)$rho
library(Phub)
example("EM.hub")
EM.hub
n0 = 5; n=100
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 10
A = matrix(runif((M+1)*n),nrow=(M+1)); diag(A[-1,])=1
rho = runif(M+1); rho = rho/sum(rho)
EM.hub(G0,A,rho,0.035)$rho
EM.hub(G0,A,rho,0.045)$rho
0 = 5; n=100
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 10; EMM.hub(G0,M,0.045)
0 = 5; n=100
A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
M = 10; EMM.hub(G0,M,0.045,rep=5)
EMM.hub
library(Phub)
EMM.hub
library(Phub)
EMM>hub
EMM.hub
library(Phub)
EMM.hub
library("Phub", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
remove.packages("Phub")
library(Phub)
EMM.hub
EM.hub
library(Phub)
EM.hub
remove.packages("Phub")
devtools::document()
library(Phub)
EM.hub
library(Phub)
ls()
rm(list=ls())
EM.hub
example(EM.hub)
example(EM.hub)
example(EM.hub)
example(EM.hub)
example(EMM.hub)
EMM.hub
M = 10; EMM.hub(G0,M,0.035)
M = 20; EMM.hub(G0,M,0.035)
M = 20; EMM.hub(G0,M,0.030)
M = 10; EMM.hub(G0,M,0.045)$rho
A = matrix(runif((M+1)*n),nrow=(M+1)); diag(A[-1,])=1
rho = runif(M+1); rho = rho/sum(rho)
EM.hub(G0,A,rho,0.045)$rho
library(Rsolnp)
EM.opt = function(G,A,rho,lam,iter=1000,tol=10^(-4)){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; M = dim(A)[1]
Pr_cond = matrix(NA,T,M)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1]; q = dim(Pr_cond)[2]
H = matrix(NA,T,q)
Htm = t(t(Pr_cond)*rho)
H = Htm/rowSums(Htm)
loglik = sum(log(rowSums(Htm)))
return(list(H=H,l=loglik))
}
## update rho: some rho may shrink to 0
hatrho = function(x,Hx){
##### need to rewrite
# Hx: colSums of H
epsi = 10^(-6)
T = dim(G)[1]
ind = which(x!=0)
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*sum(log(epsi+t[-1]))
eqft = function(t) sum(t)
len = length(ind)
pars = gosolnp(fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),UB=rep(1,len),control=list(trace=0),n.restarts=5)$pars
pars[pars<tol] = 0
x[ind] = pars
return(x)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while(count < iter & diff > 0.01){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,colSums(H))
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
#
EM.opt(G0,A,rho,0.05)$rho
EM.opt(G0,A,rho,0.05)$rho
EM.opt(G0,A,rho,0.05)$rho
EM.opt(G0,A,rho,0.08)$rho
EM.opt(G0,A,rho,0.04)$rho
EM.opt(G0,A,rho,0.035)$rho
EM.opt(G0,A,rho,0.045)$rho
EM.opt(G0,A,rho,0.040)$rho
EMM.opt = function(G,M,lam,rep=5,nohub=TRUE,iter=1000,tol=10^(-4)){
T = dim(G)[1]; n = dim(G)[2]
## repeatation
outp = list(rep); cur = rep(NA,rep)
for(r in 1:rep){
rho = runif(M+1); rho = rho/sum(rho)
A = matrix(runif((M+1)*n),nrow=(M+1))
diag(A[-1,])=1
outp[[r]] = EM.opt(G,A,rho,lam)
cur[r] = outp[[r]]$l
}
maxid = which.max(cur)
return(outp[[maxid]])
}
EMM.opt(G0,M,0.045)$rho
EMM.hub(G0,M,0.045)$rho
devtools::document()
library(Phub)
EMM.hub
example(EMM.hub)
rho
dim(A)
M
M=10
M = 10
EM.opt(G0,A,rho,0.040)$rho
EMM.opt(G0,M,0.040)$rho
EM.lasso = function(G,A,rho,lam,iter=1000,tol=0.001){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; M = dim(A)[1]
Pr_cond = matrix(NA,T,M)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1];M = dim(Pr_cond)[2]
H = matrix(NA,T,M)
Htm = t(t(Pr_cond)*rho)
H = Htm/rowSums(Htm)
loglik = sum(log(rowSums(Htm)))
return(list(H=H,l=loglik))
}
## update rho: some rho may shrink to 0
hatrho = function(x,Hx){
# Hx: colSums of H
epsi = 10^(-6)
T = dim(G)[1]
ind = which(x!=0)
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-rho[1])
eqft = function(t) sum(t)
len = length(ind)
pars = gosolnp(fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),UB=rep(1,len),control=list(trace=0),n.restarts=3)$pars
pars[pars<tol] = 0
x[ind] = pars
return(x)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
M = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,M,n)
for(m in 1:M){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while(count < iter & diff > 10^(-4)){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,colSums(H))
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
M
rho
dim(A)
dim(rho)
length(rho)
#'
#' @examples
# n0 = 5; n=100
# A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
# G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
# M = 10
# A = matrix(runif((M+1)*n),nrow=(M+1)); diag(A[-1,])=1
# rho = runif(M+1); rho = rho/sum(rho)
# EM.lasso(G0,A,rho,1)$rho
#'
library(Phub)
#'
#' @examples
# n0 = 5; n=100
# A0 = GenA(100,n0,0.4,0.1,rep(0.05,n))
# G0 = GenG(A0,1000,c(0.2,rep(0.8/n0,n0)))
# M = 10
# A = matrix(runif((M+1)*n),nrow=(M+1)); diag(A[-1,])=1
# rho = runif(M+1); rho = rho/sum(rho)
# EM.lasso(G0,A,rho,1)$rho
#'
library(Phub)
EM.lasso(G0,A,rho,1)$rho
EM.lasso(G0,A,rho,5)$rho
EM.lasso(G0,A,rho,10)$rho
EM.lasso = function(G,A,rho,lam,iter=1000,tol=10^(-4)){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; q = dim(A)[1]
Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1]; q = dim(Pr_cond)[2]
H = matrix(NA,T,q)
Htm = t(t(Pr_cond)*rho)
H = Htm/rowSums(Htm)
loglik = sum(log(rowSums(Htm)))
return(list(H=H,l=loglik))
}
## update rho: some rho may shrink to 0
hatrho = function(x,Hx){
# Hx: colSums of H
T = dim(G)[1]
ind = which(x!=0)
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-rho[1])
eqft = function(t) sum(t)
len = length(ind)
pars = gosolnp(fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),UB=rep(1,len),control=list(trace=0),n.restarts=3)$pars
pars[pars<tol] = 0
x[ind] = pars
return(x)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while(count < iter & diff > 0.01){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,colSums(H))
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
EM.lasso(G0,A,rho,20)$rho
EM.lasso = function(G,A,rho,lam,iter=1000,tol=10^(-3)){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; q = dim(A)[1]
Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1]; q = dim(Pr_cond)[2]
H = matrix(NA,T,q)
Htm = t(t(Pr_cond)*rho)
H = Htm/rowSums(Htm)
loglik = sum(log(rowSums(Htm)))
return(list(H=H,l=loglik))
}
## update rho: some rho may shrink to 0
hatrho = function(x,Hx){
# Hx: colSums of H
T = dim(G)[1]
ind = which(x!=0)
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-rho[1])
eqft = function(t) sum(t)
len = length(ind)
pars = gosolnp(fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),UB=rep(1,len),control=list(trace=0),n.restarts=3)$pars
pars[pars<tol] = 0
x[ind] = pars
return(x)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while(count < iter & diff > 0.01){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,colSums(H))
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
EM.lasso(G0,A,rho,50)$rho
EM.lasso(G0,A,rho,100)$rho
EM.lasso(G0,A,rho,10000)$rho
EM.lasso(G0,A,rho,1000000)$rho
EM.lasso(G0,A,rho,10000000)$rho
EM.lasso(G0,A,rho,50)$rho
EM.lasso = function(G,A,rho,lam,iter=1000,tol=10^(-2)){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; q = dim(A)[1]
Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1]; q = dim(Pr_cond)[2]
H = matrix(NA,T,q)
Htm = t(t(Pr_cond)*rho)
H = Htm/rowSums(Htm)
loglik = sum(log(rowSums(Htm)))
return(list(H=H,l=loglik))
}
## update rho: some rho may shrink to 0
hatrho = function(x,Hx){
# Hx: colSums of H
T = dim(G)[1]
ind = which(x!=0)
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-rho[1])
eqft = function(t) sum(t)
len = length(ind)
pars = gosolnp(fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),UB=rep(1,len),control=list(trace=0),n.restarts=3)$pars
pars[pars<tol] = 0
x[ind] = pars
return(x)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while(count < iter & diff > 0.01){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,colSums(H))
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
EM.lasso(G0,A,rho,50)$rho
EM.lasso(G0,A,rho,100)$rho
EM.lasso = function(G,A,rho,lam,iter=1000,tol=10^(-4)){
## f(G(t)|Z(t)=k,A)
cond.f = function(G,A){
T = dim(G)[1]; q = dim(A)[1]
Pr_cond = matrix(NA,T,q)
for(t in 1:T) Pr_cond[t,] = apply(t(t(A)^G[t,])*t(t(1-A)^(1-G[t,])),1,prod)
return(Pr_cond)
}
## posterior prob. Htm and loglikelihood
posterior = function(rho,Pr_cond){
T = dim(Pr_cond)[1]; q = dim(Pr_cond)[2]
H = matrix(NA,T,q)
Htm = t(t(Pr_cond)*rho)
H = Htm/rowSums(Htm)
loglik = sum(log(rowSums(Htm)))
return(list(H=H,l=loglik))
}
## update rho: some rho may shrink to 0
hatrho = function(x,Hx){
# Hx: colSums of H
T = dim(G)[1]
ind = which(x!=0)
ft = function(t) -sum(Hx[ind]*log(t)) + T*lam*(1-rho[1])
eqft = function(t) sum(t)
len = length(ind)
pars = gosolnp(fun=ft,eqfun=eqft,eqB=1,LB=rep(0,len),UB=rep(1,len),control=list(trace=0),n.restarts=3)$pars
pars[pars<tol] = 0
x[ind] = pars
return(x)
}
## update A: Am. will be 0 if rho_m=0
hatA = function(G,H){
q = dim(H)[2]; n = dim(G)[2]
HatA = matrix(NA,q,n)
for(m in 1:q){
if (all(H[,m]==0)) HatA[m,] = 0
else HatA[m,] = colSums(H[,m]*G)/sum(H[,m])
}
diag(HatA[-1,]) = 1 # No need to estimate A(m+1)m
return(HatA)
}
## EM Iteration
count = 0;diff = 1
L = vector();L[1] = 1
while(count < iter & diff > 0.01){
count = count + 1
# E Step
post = posterior(rho,cond.f(G,A))
H = post$H
L[count+1] = post$l
if(is.infinite(L[count+1])) break
# M Step
rho = hatrho(rho,colSums(H))
A = hatA(G,H)
diff = abs(L[count+1]-L[count])
}
return(list(A=A,rho=rho,l=L[count+1],iteration=count))
}
EM.lasso(G0,A,rho,50)$rho
EM.lasso(G0,A,rho,0)$rho
EM.lasso(G0,A,rho,1000000000)$rho
EM.lasso(G0,A,rho,1000000)$rho
EM.lasso(G0,A,rho,0)$rho
EM.hub(G0,A,rho,0)
